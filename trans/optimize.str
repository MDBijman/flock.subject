module optimize

imports
  flock/api

signature
  constructors
    Const : INT -> Const

strategies 

  optimize-program: p -> p'
  where (p', t) := <profile(optimize-program'; flock-debug-graph)> p ; <debug> t

  optimize-program': p -> p''
    with
     p' := <flock-add-id> p
    //; <flock-debug> p'
    ; <flock-analyse-program> p'
    ; p'' := <fixpoint-opt(optimize-program-inner | 5000)> p'

  fixpoint-opt(s|0) = id
  fixpoint-opt(s|bound): p -> <s < (fixpoint-opt(s | <dec> bound)) + id> p
  where <not(equal(|0))> bound

  optimize-program-inner: p -> p'
  where 
   p' := <oncetd(opt)> p
 ; <flock-update> p'
    
  opt: p -> p''
  where 
    p'  := <fold-expressions + remove-dead-heap-store + propagate-constant-read + remove-dead-store + remove-dead-code> p 
  ; p'' := <flock-replace-node(|p)> p'
 
strategies

  fold-expressions: Add(Int(v1), Int(v2)) -> Int(sum)
  where 
    sum := <(string-to-int, string-to-int); addi; int-to-string> (v1, v2)
  ; <concat-strings; flock-debug> ["[fold-expressions] ", v1, " + ", v2, " -> ", sum]
  
  fold-expressions: Sub(Int(v1), Int(v2)) -> Int(sub)
  where
    sub := <(string-to-int, string-to-int); subti; int-to-string> (v1, v2)
  ; <concat-strings; flock-debug> ["[fold-expressions] ", v1, " + ", v2, " -> ", sub]
  
strategies

  propagate-constant-read: a@Ref(m) -> Int(v)
  where
    <flock-debug> a
  ; Const(v) := <flock-get-value(|m)> a
  ; <concat-strings; flock-debug> ["Const value ", m, ": ", v]

  remove-dead-store: a@Assign(n, _) -> Skip()
  where
    <not(flock-is-live(|n))> a
  ; <concat-strings; flock-debug> ["dead variable ", n]

  remove-dead-heap-store: a@DerefAssign(n, _) -> Skip()
  where
    <not(flock-is-live(|n))> a
  ; as := <get-alias-set(|n)> a 
  ; <map(!(<id>, a); not(flock-is-live)|)> as
  ; <concat-strings; flock-debug> ["dead heap store ", n]

strategies

  remove-dead-code = fail //remove-empty-block <+ remove-empty-while <+ remove-skip <+ remove-dead-if <+ remove-singleton-block

  remove-empty-block: Block([]) -> Skip()
  where <flock-debug> "removing empty block"

  remove-empty-while: While(e, []) -> Skip()
  where <flock-debug> "removing empty block"

  remove-skip: Block(stmts) ->  Block(stmts')
  where
    stmts' := <retain-all(not(?Skip))> stmts
  ; <not(equal)> (stmts, stmts')
  where <flock-debug> "removing skips"
  
  remove-skip: Func(n, stmts, r) -> Func(n, stmts', r)
  where
    stmts' := <retain-all(not(?Skip))> stmts
  ; <not(equal)> (stmts, stmts')
  where <flock-debug> "removing skips"
  
  remove-skip: While(e, stmts) -> While(e, stmts')
  where
    stmts' := <retain-all(not(?Skip))> stmts
  ; <not(equal)> (stmts, stmts')
  where <flock-debug> "removing skips"
    
  remove-dead-if: IfThenElse(True, t, e)  -> t
  where <flock-debug> "removing dead if"

  remove-dead-if: IfThenElse(False, t, e) -> e
  where <flock-debug> "removing dead if"

  remove-singleton-block: Block([s]) -> s
  where <flock-debug> "unwrapping statement from block"


  